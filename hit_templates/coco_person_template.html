<html>
  <head>
    <title>Select which direction the person is facing</title>
    <!-- simpleamt depends on these libraries -->
    <script src='//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js'></script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/json3/3.3.2/json3.min.js'></script>
    <!-- end of required libraries -->
    <script src='//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js'></script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.6.0/underscore-min.js'></script>
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css" rel="stylesheet">

    <style>
      #task-container {
        margin: 0 auto;
        width: 50%;
        min-width: 700px;
      }
      #button-div {
        margin-bottom: 10px;
      }
      #counter {
        margin: 0 10px;
        font-size: 20pt;
        font-weight: bold;
      }
      img {
        height: 400px;
      }
      #direction-annotations-container {
        margin: 20pt;
        text-align: center;
      }
      #direction-annotations-shortcuts {
        margin: 0 auto;
        text-align: left;
      }
      #image-container {
        text-align: center;
      }
      #button-div {
        text-align: center;
      }
      .submit-hint {
        text-align: center;
        display: none;
        font-size: 1.5em;
        margin: 1em;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div id="task-container">
      <h2>Which direction is this person facing?</h2>
      <div id="instructions">
        <p>
          Hello! We're looking to figure out which way a person in each image is
          facing.
        </p>
        <p>
          An image may have multiple people, but we are interested only in the
          person inside the red and black box.
        </p>
        <p>
          Please mark each person as facing in one of four directions: "right",
          "left", "towards you", "away from you". If two of these seem correct,
          choose the one that looks most correct.
        </p>
        <p>
          If you absolutely cannot tell which way a person is facing, mark
          "Impossible to tell." Please use this very rarely, such as if the person
          is not visible, or you only see a small part of the person that does
          not indicate the direction.
        </p>
      </div>
      <div id="direction-annotations-shortcuts">
        Keyboard shortucuts:<br/>
        <ul>
          <li><tt>w</tt>: Away from you</li>
          <li><tt>a</tt>: Left</li>
          <li><tt>s</tt>: Towards you</li>
          <li><tt>d</tt>: Right</li>
          <!-- <li>m: Ambiguous direction</li> -->
          <li><tt>n</tt>: Impossible to tell</li>
          <li><tt>Left arrow</tt>: Previous image</li>
          <li><tt>Right arrow</tt>: Next image</li>
        </ul>
      </div>
      <div id='image-container'>
        <canvas id='image-canvas'>
          Your browser does not support canvas...
        </canvas>
      </div>
      <div id="direction-annotations-container">
        <button class="direction-annotation btn btn-default" id="direction-left" disabled>Left (A)</button>
        <button class="direction-annotation btn btn-default" id="direction-away" disabled>Away from you (W)</button>
        <button class="direction-annotation btn btn-default" id="direction-right" disabled>Right (D)</button>
        <button class="direction-annotation btn btn-default" id="direction-towards" disabled>Towards you (S)</button>
        <!-- <button class="direction-annotation btn btn-default" id="direction-ambiguous" disabled>Ambiguous direction</button> -->
        <button class="direction-annotation btn btn-default" id="impossible-to-tell" disabled>Impossible to tell (N)</button>
      </div>
      <div class="submit-hint" id="submit-hint-leftover"></div>
      <div class="submit-hint" id="submit-hint-done">Scroll down and press submit if you're done!</div>

      <div id='button-div'>
        <button id='prev-btn' class='btn btn-lg btn-primary' disabled>Back</button>
        <span id='counter'>
          <span class='counter-top'></span> / <span class='counter-bottom'></span>
        </span>
        <button id='next-btn' class='btn btn-lg btn-primary' disabled>Next</button>
      </div>
    </div>

    {% include "simpleamt.html" %}

    <script>
      $(function() {

        // Define some default input.
        var DEFAULT_INPUT = [{"image_id": 167765, "image_url": "http://mscoco.org/images/167765", "annotation": {"segmentation": [[96.36, 5.75, 126.56, 28.76, 151.01, 51.78, 182.65, 92.04, 182.65, 129.44, 182.65, 176.9, 176.9, 186.97, 149.57, 169.71, 115.06, 152.45, 69.03, 116.49, 34.52, 113.62, 18.7, 100.67, 11.51, 112.18, 11.51, 116.49, 14.38, 135.19, 23.01, 155.33, 30.2, 169.71, 14.38, 192.72, 24.45, 221.48, 37.39, 245.93, 48.9, 319.28, 58.97, 501.93, 31.64, 598.29, 0.0, 631.37, 1.44, 1.44]], "area": 41595.72534999999, "iscrowd": 0, "image_id": 167765, "bbox": [0.0, 1.44, 182.65, 629.93], "category_id": 1, "id": 183813}, "annotation_id": 183813}, {"image_id": 495312, "image_url": "http://mscoco.org/images/495312", "annotation": {"area": 77935.36530000003, "iscrowd": 0, "image_id": 495312, "bbox": [1.31, 28.26, 373.56, 470.91], "category_id": 1, "id": 183172}, "annotation_id": 183172}, {"image_id": 44474, "image_url": "http://mscoco.org/images/44474", "annotation": {"area": 52541.14914999998, "iscrowd": 0, "image_id": 44474, "bbox": [33.42, 11.94, 303.68, 407.76], "category_id": 1, "id": 183024}, "annotation_id": 183024}, {"image_id": 196842, "image_url": "http://mscoco.org/images/196842", "annotation": {"area": 3817.67415, "iscrowd": 0, "image_id": 196842, "bbox": [273.14, 82.25, 72.6, 129.68], "category_id": 1, "id": 183022, "direction": 3}, "annotation_id": 183022}]

        var input = null;

        var key_to_button_id = {
          "a": "direction-left",
          "w": "direction-away",
          "d": "direction-right",
          "s": "direction-towards",
          "n": "impossible-to-tell"
          // "m": "direction-ambiguous"
        };
        var button_id_to_direction = {
          "direction-left": 0,
          "direction-away": 1,
          "direction-right": 2,
          "direction-towards": 3,
          // "direction-ambiguous": -2,
          "impossible-to-tell": -3
        };
        var direction_to_button_id = {
          "0": "direction-left",
          "1": "direction-away",
          "2": "direction-right",
          "3": "direction-towards",
          // "-2": "direction-ambiguous",
          "-3": "impossible-to-tell"
        };

        // Direction of each person, parallel to input.
        var directions = [];

        // Some variables to track state of the HIT.
        var idx = 0;
        var enabled = false;
        var images = [];

        function main() {
          // If this is a HIT on AMT, then replace the default input with the real input.
          input = simpleamt.getInput(DEFAULT_INPUT);

          // Enable the UI if the HIT is not in preview mode.
          if (!simpleamt.isPreview()) {
            enableHit();
          }

          // Set up the directions.
          _.each(input, function() { directions.push(-1); });

          // Preload all images
          _.each(input, function(task_info) {
            var img = new Image();
            var img_url = task_info['image_url'];
            img.src = img_url;
            images.push(img);
          });

          // Setup keyboard shortcuts
          if (enabled) {
            // Highlight button on keypress so there is some visual feedback,
            // skip on keyup.
            $(document).keypress(function(e) {
              var key = String.fromCharCode(e.which).toLowerCase();
              if (key in key_to_button_id) {
                $('.direction-annotation').removeClass('active');
                $('#' + key_to_button_id[key]).addClass('active');
              }
            });

            // Handle direction marking, previous/next buttons.
            $(document).keyup(function(e) {
              var key = String.fromCharCode(e.which).toLowerCase();
              if (key in key_to_button_id) {
                $('#' + key_to_button_id[key]).click();
              } else {
                if (e.which == 39) { // right arrow
                  $('#next-btn').click();
                } else if (e.which == 37) { // left arrow
                  $('#prev-btn').click();
                }
              }
            });
          }

          render();
        }

        // Use the current index to update the image and description
        function render() {
          if (!images[idx].complete) {
            images[idx].onload = function() { render(images); }
            return;
          }

          // We're going to draw 2 rectangles around the image with the same
          // strokeWidth. To avoid issues at the borders, we'll create a canvas
          // with a 2*strokeWidth padding on all sides, and draw the image at
          // the center.
          var boundingBox = input[idx]['annotation']['bbox'].slice(); // copy
          var strokeWidth = images[idx].height / 75;
          // boundingBox is relative to image; make it relative to canvas.
          boundingBox[0] += 2*strokeWidth;
          boundingBox[1] += 2*strokeWidth;

          // Set up the image.
          var jCanvas = $('#image-canvas');
          var canvas = jCanvas[0];
          // Add 2*strokeWidth empty padding around image.
          canvas.width = images[idx].width + 4*strokeWidth;
          canvas.height = images[idx].height + 4*strokeWidth;
          var ctx = canvas.getContext("2d");
          // Draw image at the center.
          ctx.drawImage(images[idx], 2*strokeWidth, 2*strokeWidth);

          function updateBoxForStroke(boxDimensions, strokeWidth) {
            // Scale the bounding box so that when you stroke the border, the
            // inside contains as much space as the original bounding box. This
            // is necessary since the Canvas API draws half of the "strokeWidth"
            // inside the rectangle.
            //
            // Params:
            //   boxDimensions: [topLeftX, topLeftY, width, height] of a
            //     bounding box.
            //  strokeWidth (int): Stroke width used for canvas.
            //
            // Returns:
            //   [topLeftX, topLeftY, width, height] of updated bounding box.
            var boxStartX = boxDimensions[0],
                boxStartY = boxDimensions[1],
                boxWidth = boxDimensions[2],
                boxHeight = boxDimensions[3];

            // Move strokeWidth/2 left and up.
            boxStartX = boxStartX - (strokeWidth / 2.0);
            boxStartY = boxStartY - (strokeWidth / 2.0);
            // Increase dimensions by strokeWidth (since we lose strokeWidth/2
            // on each side to the stroke).
            boxWidth = boxWidth + strokeWidth;
            boxHeight = boxHeight + strokeWidth;

            return [boxStartX, boxStartY, boxWidth, boxHeight];
          }

          function clipBoxInCanvas(boxDimensions, canvasDimensions) {
            // Clips bounding box so it is within the canvas.
            //
            // Params:
            //   boxDimensions: [topLeftX, topLeftY, width, height] of a
            //     bounding box.
            //   canvasDimensions: [width, height] of the Canvas.
            //
            // Returns:
            //   [topLeftX, topLeftY, width, height] of updated bounding box.
            //
            var boxStartX = boxDimensions[0],
                boxStartY = boxDimensions[1],
                boxWidth = boxDimensions[2],
                boxHeight = boxDimensions[3],
                boxEndX = boxStartX + boxWidth,
                boxEndY = boxStartY + boxHeight,
                canvasWidth = canvasDimensions[0],
                canvasHeight = canvasDimensions[1];

            boxStartX = Math.max(boxStartX, 0);
            boxStartY = Math.max(boxStartY, 0);
            boxEndX   = Math.min(boxEndX, canvasWidth);
            boxEndY   = Math.min(boxEndY, canvasHeight);
            return [boxStartX, boxStartY, boxEndX - boxStartX, boxEndY - boxStartY];
          }

          // Draw a red outline around a black outline, which should hopefully
          // provide enough contrast. Note that the inside of the bounding
          // box itself will not be stroked, since we scale the bounding box
          // to stroke only the outside.

          // Leave enough room for both rectangles. This one will squeeze
          // 0.5 stroke widths into the rectangle, and the other one will
          // squeeze 1.0 stroke widths into the rectangle; so we need to
          // pretend like we're going to draw a 3*strokeWidth stroke.
          var outerBoxDimensions = clipBoxInCanvas(
            updateBoxForStroke(boundingBox, 3*strokeWidth),
            [canvas.width, canvas.height]);

          ctx.strokeStyle = "red";
          ctx.lineWidth = strokeWidth;
          ctx.strokeRect(outerBoxDimensions[0],
                         outerBoxDimensions[1],
                         outerBoxDimensions[2],
                         outerBoxDimensions[3]);

          ctx.strokeStyle = "black";
          var innerBoxDimensions = clipBoxInCanvas(
            updateBoxForStroke(boundingBox, strokeWidth),
            [canvas.width, canvas.height]);
          ctx.strokeRect(innerBoxDimensions[0],
                         innerBoxDimensions[1],
                         innerBoxDimensions[2],
                         innerBoxDimensions[3]);

          jCanvas.css('height', '500px');
          jCanvas.css('max-width', '700px');

          // Refresh the counter
          $('.counter-top').text(idx + 1);
          $('.counter-bottom').text(input.length);

          // If the UI is enabled, enable or disable the buttons depending on
          // the index.
          if (enabled) {
            var prev_btn = $('#prev-btn');
            var next_btn = $('#next-btn');
            prev_btn.prop('disabled', true);
            next_btn.prop('disabled', true);
            $('.direction-annotation').prop('disabled', false);
            // If an answer was already provided for this image, set the
            // respective button to be active.
            if (directions[idx] != -1
                && $('.direction-annotation.active').length == 0) {
              $('#' + direction_to_button_id[directions[idx]]).addClass('active');
            }
            if (idx > 0) {
              prev_btn.prop('disabled', false);
            }
            if (idx < input.length - 1) next_btn.prop('disabled', false);
          }
        }

        // Mark the selected button as active.
        $('.direction-annotation').click(function() {
          $('.direction-annotation').removeClass('active');
          $(this).addClass('active');
          if (idx < input.length - 1) {
            setIdx(idx + 1);
          } else {
            $('#submit-hint-done').show();
          }
        });

        function updateSelectedDirection() {
          selected_direction_buttons = $('.direction-annotation.active');
          if (selected_direction_buttons.length == 1) {
            selected_direction_id = selected_direction_buttons[0].id;
            directions[idx] = button_id_to_direction[selected_direction_id];
          }
        }

        // Update the index, and save the text in the text area.
        function setIdx(new_idx) {
          if (new_idx < 0 || new_idx >= input.length) return;

          updateSelectedDirection();
          $('.direction-annotation').removeClass('active');

          idx = new_idx;
          render();
        }

        // Enable the UI.
        function enableHit() {
          enabled = true;

          // Enable components
          $('#next-btn').click(function() { setIdx(idx + 1) });
          $('#prev-btn').click(function() { setIdx(idx - 1) });
          $('#text-area').prop('disabled', false);
          $('#submit-btn').prop('disabled', false);

          // Set up submit handler.
          simpleamt.setupSubmit();
          $('#submit-btn').click(function() {
            updateSelectedDirection();
            invalid_directions = _.filter(directions, function(d) { return d == -1; });
            if (invalid_directions.length > 0) {
              alert('Direction for image ' + invalid_directions.join(', ') + ' missing.');
              return false;
            }
            var output = _.map(_.zip(input, directions), function(x) {
              return {'input': x[0], 'direction': x[1]};
            });
            simpleamt.setOutput(output);
          });
        }

        main();
      });
    </script>
  </body>
</html>
